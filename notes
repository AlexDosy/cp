bubble sort-
   this sorting algortihm is o(n2) for time complexity- uses two for loops compares adjacent elements throught and get the sorted array.  for (i=0;i<n-1;i++){ for(j=0;j<n-i-1;j++){}}

selection sort-
   this sorting algo is also o(n2) for time complex. - use two for loops considering first element as minimum value and search throught for othe small elements. for (i=0;i<n-1;i++){ for(j=i+1;j<n;j++){}}

insertion sort- 
   this sorting algo is also o(n2) for time complex. - use a for loop and a while loop for algo. consider whole array as sorted and unsorted and inserts smallest element to coorect position. 
    for(i=1;i<n;i++){ int j=i-1; int current=arr[i]; while(j>=0 && arr[j]>key){j--;}}

    

21/10
LINKED LIST - connected nodes and each node has a value and an address
    LinkedList list= new LinkedList();
   addFirst()
   addLast()
   contains()
   indexOf()
   size() 
arranging odd and even node on top of eachother
using two pointers

22/10
reversing linked list - use two pointers prev=null, curr= head while(curr!=null) 
finding maxTwinSum ith and n-1-ith:
   we need to get half on linkedlist using two pointer fast and slow, after reverse from the slow, then add that linked list with head while(secondhalf!=null) return max of the sum

23/10
bINARY TREE
   maxdepth of binary tree recursive fn- left and right node equates to null add 1 to max of depths
   leaf similar return boolean if two binary tree nodes leaf node are same- recursive fn same as above two variable for equating leaves
      getting the leaves in another fn recursive DFS algorithm


15/01
Arrys, Hashmap:
   encoding and decoding by adding length of each string at begining followed by hash
   anagrams
   top k elements using bucket sort and hashmap reduced complexity to o(n)

16/01
   prod of all elements without index element to store at index: using prefix and postfix and multiplying togetherin the same array  o(n) 
   while bruteforce aproach takes o(n^2) and its using if, continues statements
   Valid Sudoku :
      bruteforce validate rows, colums, square in range(9) individually
      while using hashmap, and checking using intializing dict using collections.defaultdict(set) and checking for rows , column, for square we did a neet trick of int dividing r and c with 3 (sqaure is 3*3)
      this gave [(0-2,0-2)] posibile sqaure and validate hashmap like that 
   longest sequence:
      while bruteforce can be done using curr, streak
      o(n) algo is using set and check if i-1 exist in that set, and proceed with the same stuff length iis added and checked and max of logest and length is returned

28/01
   max rainwater bars can hold:
      bruteforce : o(n^2) j*min(height[j], height[i)
      did using two pointer l=0, r=len(heights) incrementing l and decrementing r to suit req
   same type problem(rainwater) hard
      two pointer soln and add together the rainwater holding capacity

   Stochmarket (easy problem)
      buy low sell high
      use two pointers l =0, r='1' after do the soln

29/01
   logest substring without repeating char
      bruteforce: two for loops inside first  defined a set to determine the unique string and in second if two break out if two same chars are present
      sliding window l=0, one loop inside while in s, l+=1 s[l]
30/01
   longest repeating substring with charater replacment: using sliding window didnt understand that much
5/02
   return the min substring from s which has all characters in t
      used sliding window, o(n) soln, res=[-1,-1],resLen=float("infinity"), have, need, hashmaps for counts

06/02
   checking all open bracket are closed in order
   bruteforce exceeds timelimit using while and replace
   using stack we could complete in o(n) and checks in closeToOpen hashmap,

   Making fn for pop, top, getmin in stack 
   for getmin() define a duplicate minStack along with defining stack

07/02
   Solving reverse polish notation(RPN) using stack. bruteforce is to traverse through element and comute each resuat and update the strings
   
   finding min of sorted rotated array, bruteforce min(), o(nlogn) we use middle pointer along with left and right pointer

08/02
   search an element in an array using binary search using m,l,r

09/02
   merge two list in correctly sorted order, uses iteration

10/02
   reorder linked list fromfirst the last of last half, first find two list half the initial second half is reversed, the reorderd using two pointers
   remove nth node from end of Linked list> put left, right pointer, right should be at nth node at start when right reach null, left is the node which we have to remove, devise a dummy node=ListNode(0,head) 

11/02
   copy random list -> using hashmap and two pass 
12/02
   detect duplicate in list using floyd cycle detection algorithm-> fast ,slow meet at one point from there another slow will meet current slow at one point thats th result (--()))

13/02
   Merge K Sorted Linked Lists-> using mergeList fn

14/02
   invert a binary tree : used recursion after swaping left and right nodes
   max depth of a tree, using dfs
15/02
   diameter of a binary trree using dfs
   check if 2 tree are equal-> recursion dfs

16/02
   check for is it a subtree, using recursion and same tree fn 

18/02
   return kth index of BST, iterative search

19/02
   max path sum using dfs
   
20/02
   heappush and heappop for getting median from a random array
21/02
   backtracking to find all the possible sum combination of target using descision tree

  
