class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = val === undefined ? 0 : val;
        this.next = next === undefined ? null : next;
    }
}

function deleteMiddle(head: ListNode | null): ListNode | null {
    // Base case: if the list is empty or only one element is present
    if (!head || !head.next) return null;

    let slow = head;
    let fast = head;
    let prev: ListNode | null = null;

    // Move fast pointer two steps and slow pointer one step at a time
    // When the fast pointer reaches the end, the slow pointer will be at the middle
    while (fast && fast.next) {
        fast = fast.next.next;
        prev = slow;
        slow = slow.next!;
    }

    // `slow` is now pointing to the middle node, and `prev` is pointing to the node before it
    if (prev) {
        prev.next = slow.next;
    }

    return head;
}

We use a two-pointer approach, where slow moves one step at a time, and fast moves two steps at a time.

When fast reaches the end of the list, slow will be at the middle node.

We keep track of the node before slow using prev, which allows us to remove the middle node by updating prev.next to slow.next.
